# -*- coding: utf-8 -*-
"""Enkeltmannsoppgave.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_kqQaH2jU4V6FUH4ZvvIksvkIkVago4q
"""

import matplotlib.pyplot as plt
import numpy as np
import time


def Runge_Kutta_Fehlberg(func, yinit, x_range, h):
    m = len(yinit)
    n = int((x_range[-1] - x_range[0])/h)
    
    x = x_range[0]
    y = yinit
    
    xsol = np.empty(0)
    xsol = np.append(xsol, x)

    ysol = np.empty(0)
    ysol = np.append(ysol, y)

    for i in range(n):
        k1 = func(x, y)

        yp2 = y + k1*(h/5)

        k2 = func(x+h/5, yp2)

        yp3 = y + k1*(3*h/40) + k2*(9*h/40)

        k3 = func(x+(3*h/10), yp3)

        yp4 = y + k1*(3*h/10) - k2*(9*h/10) + k3*(6*h/5)

        k4 = func(x+(3*h/5), yp4)

        yp5 = y - k1*(11*h/54) + k2*(5*h/2) - k3*(70*h/27) + k4*(35*h/27)

        k5 = func(x+h, yp5)

        yp6 = y + k1*(1631*h/55296) + k2*(175*h/512) + k3*(575*h/13824) + k4*(44275*h/110592) + k5*(253*h/4096)

        k6 = func(x+(7*h/8), yp6)

        for j in range(m):
            y[j] = y[j] + h*(37*k1[j]/378 + 250*k3[j]/621 + 125*k4[j]/594 + 512*k6[j]/1771)

        x = x + h
        xsol = np.append(xsol, x)

        for r in range(m):
            ysol = np.append(ysol, y[r])  

    return [xsol, ysol]

def estimate(func, func_exact, x, yinit, h):
  start = time.time()
  [ts, ys] = Runge_Kutta_Fehlberg(func, yinit, x, h)
  end = time.time()
  print("Beregningstid: ", end - start, "sekunder")
  dt = int((x[-1]-x[0])/h)
  t = [x[0]+i*h for i in range(dt+1)] 

  yexact = func_exact(dt, t)

  y_diff = ys - yexact
  print("Høyeste global feil =", np.max(abs(y_diff)))
  print("Akummulert relativ feil = ", np.sum(abs(y_diff)))

  plt.plot(ts, ys, 'rs')
  plt.plot(t, yexact, 'b')
  plt.xlim(x[0], x[1])
  plt.legend(["Runge-Kutta-Fehlberg", "Nøyaktig løsning"], loc=1)
  plt.xlabel('x', fontsize=17)
  plt.ylabel('y', fontsize=17)
  plt.tight_layout()
  plt.show()
  #plt.savefig('Fig.png', dpi=600)

def diff_func_1(x, y):
    dy = np.zeros((len(y)))
    dy[0] = np.exp(-2*x) - 2*y[0]
    return dy

def diff_func_1_exact(dt, t):
    yexact = []
    for i in range(dt+1):
      ye = (1.0 / 10) * np.exp(-2 * t[i]) + t[i] * np.exp(-2 * t[i])
      yexact.append(ye)
    return yexact

def diff_func_2(x, y):
    dy = np.zeros((len(y)))
    dy[0] = 2*x - 4*x*y
    return dy

def diff_func_2_exact(dt, t):
    yexact = []
    for i in range(dt+1):
      ye = 0.5 * (1 + 7 * np.exp(-2*t[i]**2))
      yexact.append(ye)
    return yexact

if __name__ == "__main__":
  estimate(diff_func_1, diff_func_1_exact, np.array([0.0, 2.0]), np.array([1.0/10]), 0.00015)
  estimate(diff_func_2, diff_func_2_exact, np.array([0.0, 2.0]), np.array([4.0]), 0.00015)

from mpl_toolkits.mplot3d import Axes3D

def Runge_Kutta_Fehlberg_Error_Tolerance(func, yinit, x_range, h):
    m = len(yinit)
    n = int((x_range[-1] - x_range[0])/h)
    
    x = x_range[0]
    y = yinit
    
    xsol = np.empty(0)
    xsol = np.append(xsol, x)

    ysol = np.empty(0)
    ysol = np.append(ysol, y)

    for i in range(n):
        k1 = func(x, y)

        yp2 = y + k1*(h/5)

        k2 = func(x+h/5, yp2)

        yp3 = y + k1*(3*h/40) + k2*(9*h/40)

        k3 = func(x+(3*h/10), yp3)

        yp4 = y + k1*(3*h/10) - k2*(9*h/10) + k3*(6*h/5)

        k4 = func(x+(3*h/5), yp4)

        yp5 = y - k1*(11*h/54) + k2*(5*h/2) - k3*(70*h/27) + k4*(35*h/27)

        k5 = func(x+h, yp5)

        yp6 = y + k1*(1631*h/55296) + k2*(175*h/512) + k3*(575*h/13824) + k4*(44275*h/110592) + k5*(253*h/4096)

        k6 = func(x+(7*h/8), yp6)

        for j in range(m):
            y[j] = y[j] + h*(37*k1[j]/378 + 250*k3[j]/621 + 125*k4[j]/594 + 512*k6[j]/1771)

        x = x + h
        xsol = np.append(xsol, x)

        for r in range(m):
            ysol = np.append(ysol, y[r]) 

    return [xsol, ysol]

def estimate_without_exact(func, x, yinit, h):
  start = time.time()
  [ts, ys] = Runge_Kutta_Fehlberg_Error_Tolerance(func, yinit, x, h)
  end = time.time()
  print("Beregningstid: ", end - start, "sekunder")
  dt = int((x[-1]-x[0])/h)
  t = [x[0]+i*h for i in range(dt+1)] 

  y = [[], [], []]
  for i in range(0, len(ys), 3):
    y[0].append(ys[i])
    y[1].append(ys[i+1])
    y[2].append(ys[i+2])

  #plt.plot(ts, y[0], '1')
  plt.plot(y[0], y[2], linewidth=1.0)
  plt.xlim(-25, 25)
  plt.ylim(0, 50)
  plt.legend(["Lorenz Runge-Kutta-Fehlberg"], loc=1)
  plt.xlabel('x', fontsize=17)
  plt.ylabel('y', fontsize=17)
  plt.tight_layout()
  plt.show()
  fig = plt.figure()
  ax = fig.add_subplot(111, projection='3d')
  ax.plot(y[0], y[1], y[2])

def dydt(t, y_v):
  s = 10.
  r = 28.
  b = 8./3.
  x, y, z = y_v
  return np.array([
      -s*x + s*y,
      -x*z + r*x - y,
      x*y-b*z
  ])


#%% run
h = 0.01
x = np.array([0, 50])
y_0 = np.array([5., 5., 5.])

estimate_without_exact(dydt, x, y_0, h)

def error_computetime(func, func_exact, x, yinit, h):
  start = time.time()
  [ts, ys] = Runge_Kutta_Fehlberg(func, yinit, x, h)
  end = time.time()
  dt = int((x[-1]-x[0])/h)
  t = [x[0]+i*h for i in range(dt+1)] 

  yexact = func_exact(dt, t)

  y_diff = ys - yexact
  return [end - start, np.max(abs(y_diff))]
  #plt.savefig('Fig.png', dpi=600)

if __name__ == "__main__":
  h_start = 0.001
  steg = 100
  steg_lengde = 0.0001
  func1_time = []
  func1_error = []
  func2_time = []
  func2_error = []
  for i in range(steg):
    result = error_computetime(diff_func_1, diff_func_1_exact, np.array([0.0, 2.0]), np.array([1.0/10]), i*steg_lengde + h_start)
    func1_time.append(result[0])
    func1_error.append(result[1])
    result = error_computetime(diff_func_2, diff_func_2_exact, np.array([0.0, 2.0]), np.array([4.0]), i*steg_lengde + h_start)
    func2_time.append(result[0])
    func2_error.append(result[1])
  
print(func2_time)
print(func2_error)

def plot_error_against_time(time, error):
  plt.plot(time, error, 'rs')
  plt.legend(["Feil og tid"], loc=1)
  plt.xlabel('tid', fontsize=17)
  plt.ylabel('feil', fontsize=17)
  plt.tight_layout()
  plt.show()

plot_error_against_time(func2_time, func2_error)
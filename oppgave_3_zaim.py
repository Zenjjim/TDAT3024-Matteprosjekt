# -*- coding: utf-8 -*-
"""Oppgave_3_Zaim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ziUTUznVfuY58AyW9Qrh52urhVUErqif
"""

# Implementer varianten av Eulers metode gitt i likning (6) i avnsitt 4.1. Og test metoden p ̊a systemet som best ̊ar av likningene (3) og (4)._
import numpy as np

# Copy+Paste from oppgave 1
def exp(Omega, h) :
  I = np.identity(Omega.shape[0])
  omega = np.sqrt(Omega[0][1]**2+Omega[0][2]**2+Omega[1][2]**2)

  return I + (1-np.cos(h*omega))*(Omega/omega)**2 + np.sin(h*omega)*(Omega/omega)

# I er treghetsmoment, W_i resultatene og L er dreiemomentet
def calculate_omega_i(I, W_i, L):
    I_inv = np.linalg.inv(I)
    W_t = np.transpose(W_i)
    return I_inv @ W_t @ L

def Euler(h, X_0, I, L):
    W_i = [X_0]
    for i in range(1, h):
        # For all W-values after w0
        omega_i = calculate_omega_i(I, W_i, L)
        # Find Omega formel 18
        Omega = np.matrix([[0, -omega_i[2], omega_i[1]],
                        [omega_i[2], 0, -omega_i[0]],
                        [-omega_i[1], omega_i[0], 0]])
        # Calculate W_i+1
        W_i.append(W_i[-1]*exp(h=h, Omega=Omega))
    return W_i

def Euler(h, X_0, omega_i):
    W_i = [X_0]
    for i in range(1, h):
        # Find Omega formel 18
        Omega = np.matrix([[0, -omega_i[2], omega_i[1]],
                        [omega_i[2], 0, -omega_i[0]],
                        [-omega_i[1], omega_i[0], 0]])
        # Calculate W_i+1
        W_i.append(W_i[-1]*exp(h=h, Omega=Omega))
    return W_i

